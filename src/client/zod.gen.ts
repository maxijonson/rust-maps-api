// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const ResponseStatus = z.enum(["Success", "Failed"]);

export type ResponseStatusZodType = z.infer<typeof ResponseStatus>;

export const MetaDto = z.object({
  status: z.optional(ResponseStatus),
  statusCode: z.optional(z.int()),
  errors: z.optional(z.union([z.array(z.string()), z.null()])),
});

export type MetaDtoZodType = z.infer<typeof MetaDto>;

export const PagedMetaDto = MetaDto.and(
  z.object({
    page: z.optional(z.union([z.int(), z.null()])),
    itemsPerPage: z.optional(z.union([z.int(), z.null()])),
    totalItems: z.optional(z.union([z.int(), z.null()])),
    lastPage: z.optional(z.union([z.boolean(), z.null()])),
  }),
);

export type PagedMetaDtoZodType = z.infer<typeof PagedMetaDto>;

export const MapThumbnailApidto = z.object({
  mapId: z.optional(z.union([z.string(), z.null()])),
  seed: z.optional(z.int()),
  size: z.optional(z.int()),
  url: z.optional(z.union([z.string(), z.null()])),
});

export type MapThumbnailApidtoZodType = z.infer<typeof MapThumbnailApidto>;

export const PagedServiceResponseOfIEnumerableOfMapThumbnailApidto = z.object({
  meta: z.optional(z.union([PagedMetaDto, z.null()])),
  data: z.optional(z.union([z.array(MapThumbnailApidto), z.null()])),
});

export type PagedServiceResponseOfIEnumerableOfMapThumbnailApidtoZodType = z.infer<
  typeof PagedServiceResponseOfIEnumerableOfMapThumbnailApidto
>;

export const MapSearchParametersPublicApi = z.record(z.string(), z.never());

export type MapSearchParametersPublicApiZodType = z.infer<typeof MapSearchParametersPublicApi>;

export const MinMaxFilterDto = z.object({
  min: z.optional(z.int()),
  max: z.optional(z.int()),
});

export type MinMaxFilterDtoZodType = z.infer<typeof MinMaxFilterDto>;

export const BiomeTypes = z.unknown();

export type BiomeTypesZodType = z.infer<typeof BiomeTypes>;

export const BiomeFilterDto = z.object({
  type: z.optional(BiomeTypes),
  settings: z.optional(z.union([MinMaxFilterDto, z.null()])),
});

export type BiomeFilterDtoZodType = z.infer<typeof BiomeFilterDto>;

export const MonumentTypes = z.unknown();

export type MonumentTypesZodType = z.infer<typeof MonumentTypes>;

export const SelectionStatus = z.enum(["Wanted", "NotWanted", "NoPreference"]);

export type SelectionStatusZodType = z.infer<typeof SelectionStatus>;

export const MonumentFilterDto = z.object({
  type: z.optional(MonumentTypes),
  selectionStatus: z.optional(SelectionStatus),
  requiredBiomes: z.optional(z.union([z.array(BiomeTypes), z.null()])),
  blockedBiomes: z.optional(z.union([z.array(BiomeTypes), z.null()])),
});

export type MonumentFilterDtoZodType = z.infer<typeof MonumentFilterDto>;

export const MapSearchQueryDto = z.object({
  size: z.optional(z.union([MinMaxFilterDto, z.null()])),
  biomes: z.optional(z.union([z.array(BiomeFilterDto), z.null()])),
  monuments: z.optional(z.union([MinMaxFilterDto, z.null()])),
  largeMonuments: z.optional(z.union([z.array(MonumentFilterDto), z.null()])),
  gasStations: z.optional(z.union([MinMaxFilterDto, z.null()])),
  supermarkets: z.optional(z.union([MinMaxFilterDto, z.null()])),
  warehouses: z.optional(z.union([MinMaxFilterDto, z.null()])),
  lighthouses: z.optional(z.union([MinMaxFilterDto, z.null()])),
  islands: z.optional(z.union([MinMaxFilterDto, z.null()])),
  landPercentageOfMap: z.optional(z.union([MinMaxFilterDto, z.null()])),
  caves: z.optional(z.union([MinMaxFilterDto, z.null()])),
  swamps: z.optional(z.union([MinMaxFilterDto, z.null()])),
  mountains: z.optional(z.union([MinMaxFilterDto, z.null()])),
  icebergs: z.optional(z.union([MinMaxFilterDto, z.null()])),
  iceLakes: z.optional(z.union([MinMaxFilterDto, z.null()])),
  rivers: z.optional(z.union([MinMaxFilterDto, z.null()])),
  waterWells: z.optional(z.union([MinMaxFilterDto, z.null()])),
  lakes: z.optional(z.union([MinMaxFilterDto, z.null()])),
  canyons: z.optional(z.union([MinMaxFilterDto, z.null()])),
  oases: z.optional(z.union([MinMaxFilterDto, z.null()])),
  buildableRocks: z.optional(z.union([MinMaxFilterDto, z.null()])),
});

export type MapSearchQueryDtoZodType = z.infer<typeof MapSearchQueryDto>;

export const MapSearchRequest = z.object({
  searchQuery: z.optional(MapSearchQueryDto),
});

export type MapSearchRequestZodType = z.infer<typeof MapSearchRequest>;

export const MapGenerationStats = z.object({
  current: z.optional(z.int()),
  allowed: z.optional(z.int()),
});

export type MapGenerationStatsZodType = z.infer<typeof MapGenerationStats>;

export const MapGenerationStatsOverviewDto = z.object({
  concurrent: z.optional(z.union([MapGenerationStats, z.null()])),
  monthly: z.optional(z.union([MapGenerationStats, z.null()])),
});

export type MapGenerationStatsOverviewDtoZodType = z.infer<typeof MapGenerationStatsOverviewDto>;

export const ServiceResponseOfMapGenerationStatsOverviewDto = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([MapGenerationStatsOverviewDto, z.null()])),
});

export type ServiceResponseOfMapGenerationStatsOverviewDtoZodType = z.infer<
  typeof ServiceResponseOfMapGenerationStatsOverviewDto
>;

export const GetMapGenLimits = z.object({
  orgId: z.optional(z.union([z.string(), z.null()])),
});

export type GetMapGenLimitsZodType = z.infer<typeof GetMapGenLimits>;

export const PartialMapDto = z.object({
  id: z.optional(z.union([z.string(), z.null()])),
});

export type PartialMapDtoZodType = z.infer<typeof PartialMapDto>;

export const ServiceResponseOfPartialMapDto = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([PartialMapDto, z.null()])),
});

export type ServiceResponseOfPartialMapDtoZodType = z.infer<typeof ServiceResponseOfPartialMapDto>;

export const MapStates = z.enum(["Active", "InQueue", "Generating", "Processing", "Uploading"]);

export type MapStatesZodType = z.infer<typeof MapStates>;

export const MapStatusDto = z.object({
  mapId: z.optional(z.union([z.string(), z.null()])),
  queuePosition: z.optional(z.union([z.int(), z.null()])),
  state: z.optional(MapStates),
  currentStep: z.optional(z.union([z.string(), z.null()])),
  lastGeneratorPingUtc: z.optional(z.union([z.iso.datetime(), z.null()])),
});

export type MapStatusDtoZodType = z.infer<typeof MapStatusDto>;

export const ServiceResponseOfMapStatusDto = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([MapStatusDto, z.null()])),
});

export type ServiceResponseOfMapStatusDtoZodType = z.infer<typeof ServiceResponseOfMapStatusDto>;

export const MapGenerationRequestDto = z.object({
  size: z.optional(z.int().gte(1000).lte(6000)),
  seed: z.optional(z.int().gt(0)),
  staging: z.optional(z.boolean()),
});

export type MapGenerationRequestDtoZodType = z.infer<typeof MapGenerationRequestDto>;

export const Coordinates = z.object({
  x: z.optional(z.int()),
  y: z.optional(z.int()),
});

export type CoordinatesZodType = z.infer<typeof Coordinates>;

export const MonumentApidto = z.object({
  type: z.optional(MonumentTypes),
  coordinates: z.optional(Coordinates),
  nameOverride: z.optional(z.union([z.string(), z.null()])),
});

export type MonumentApidtoZodType = z.infer<typeof MonumentApidto>;

export const Biomes = z.object({
  s: z.optional(z.number()),
  d: z.optional(z.number()),
  f: z.optional(z.number()),
  t: z.optional(z.number()),
  j: z.optional(z.number()),
});

export type BiomesZodType = z.infer<typeof Biomes>;

export const MapApidto = z.object({
  id: z.optional(z.union([z.string(), z.null()])),
  type: z.optional(z.union([z.string(), z.null()])),
  seed: z.optional(z.int()),
  size: z.optional(z.int()),
  saveVersion: z.optional(z.int()),
  url: z.optional(z.union([z.string(), z.null()])),
  rawImageUrl: z.optional(z.union([z.string(), z.null()])),
  imageUrl: z.optional(z.union([z.string(), z.null()])),
  imageIconUrl: z.optional(z.union([z.string(), z.null()])),
  thumbnailUrl: z.optional(z.union([z.string(), z.null()])),
  isStaging: z.optional(z.boolean()),
  isCustomMap: z.optional(z.boolean()),
  canDownload: z.optional(z.boolean()),
  downloadUrl: z.optional(z.union([z.string(), z.null()])),
  totalMonuments: z.optional(z.int()),
  monuments: z.optional(z.union([z.array(MonumentApidto), z.null()])),
  landPercentageOfMap: z.optional(z.int()),
  biomePercentages: z.optional(z.union([Biomes, z.null()])),
  islands: z.optional(z.int()),
  mountains: z.optional(z.int()),
  iceLakes: z.optional(z.int()),
  rivers: z.optional(z.int()),
  lakes: z.optional(z.int()),
  canyons: z.optional(z.int()),
  oases: z.optional(z.int()),
  buildableRocks: z.optional(z.int()),
});

export type MapApidtoZodType = z.infer<typeof MapApidto>;

export const ServiceResponseOfMapApidto = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([MapApidto, z.null()])),
});

export type ServiceResponseOfMapApidtoZodType = z.infer<typeof ServiceResponseOfMapApidto>;

export const QueryRequest = z.record(z.string(), z.never());

export type QueryRequestZodType = z.infer<typeof QueryRequest>;

export const IslandConfiguration = z.object({
  enabled: z.optional(z.boolean()),
  intensity: z.optional(z.int()),
});

export type IslandConfigurationZodType = z.infer<typeof IslandConfiguration>;

export const MountainConfiguration = z.object({
  reduceMountains: z.optional(z.boolean()),
});

export type MountainConfigurationZodType = z.infer<typeof MountainConfiguration>;

export const TiersConfiguration = z.object({
  enabled: z.optional(z.boolean()),
  tier0Percentage: z.optional(z.union([z.number(), z.null()])),
  tier1Percentage: z.optional(z.union([z.number(), z.null()])),
  tier2Percentage: z.optional(z.union([z.number(), z.null()])),
});

export type TiersConfigurationZodType = z.infer<typeof TiersConfiguration>;

export const BiomesConfiguration = z.object({
  enabled: z.optional(z.boolean()),
  aridPercentage: z.optional(z.union([z.number(), z.null()])),
  temperatePercentage: z.optional(z.union([z.number(), z.null()])),
  tundraPercentage: z.optional(z.union([z.number(), z.null()])),
  arcticPercentage: z.optional(z.union([z.number(), z.null()])),
  junglePercentage: z.optional(z.union([z.number(), z.null()])),
});

export type BiomesConfigurationZodType = z.infer<typeof BiomesConfiguration>;

export const BiomeAngle = z.enum([
  "TopSnowBottomDesert",
  "LeftDesertRightSnow",
  "TopDesertBottomSnow",
  "LeftSnowRightDesert",
  "Default",
]);

export type BiomeAngleZodType = z.infer<typeof BiomeAngle>;

export const LootAngle = z.enum([
  "TopTier2BottomTier0",
  "LeftTier2RightTier0",
  "TopTier0BottomTier2",
  "LeftTier0RightTier2",
  "Default",
]);

export type LootAngleZodType = z.infer<typeof LootAngle>;

export const TerrainConfiguration = z.object({
  islandConfig: z.optional(z.union([IslandConfiguration, z.null()])),
  mountainConfig: z.optional(z.union([MountainConfiguration, z.null()])),
  tierConfig: z.optional(z.union([TiersConfiguration, z.null()])),
  biomeConfig: z.optional(z.union([BiomesConfiguration, z.null()])),
  flattenShoreAndBay: z.optional(z.union([z.boolean(), z.null()])),
  biomeAxisAngle: z.optional(z.union([BiomeAngle, z.null()])),
  lootAxisAngle: z.optional(z.union([LootAngle, z.null()])),
});

export type TerrainConfigurationZodType = z.infer<typeof TerrainConfiguration>;

export const MonumentBiomePreference = z.object({
  biomeType: z.optional(BiomeTypes),
  selection: z.optional(SelectionStatus),
});

export type MonumentBiomePreferenceZodType = z.infer<typeof MonumentBiomePreference>;

export const BasicMonumentConfiguration = z.object({
  type: z.optional(MonumentTypes),
  blocked: z.optional(z.boolean()),
  allowedToSetBiomes: z.optional(z.boolean()),
  biomePreferences: z.optional(z.union([z.array(MonumentBiomePreference), z.null()])),
});

export type BasicMonumentConfigurationZodType = z.infer<typeof BasicMonumentConfiguration>;

export const LargeMonumentConfiguration = BasicMonumentConfiguration.and(
  z.object({
    desired: z.optional(z.boolean()),
  }),
);

export type LargeMonumentConfigurationZodType = z.infer<typeof LargeMonumentConfiguration>;

export const BiomePreference = z.object({
  enabled: z.optional(z.boolean()),
  biome: z.optional(BiomeTypes),
});

export type BiomePreferenceZodType = z.infer<typeof BiomePreference>;

export const MonumentAlignment = z.enum(["Top", "Left", "Right", "Bottom"]);

export type MonumentAlignmentZodType = z.infer<typeof MonumentAlignment>;

export const OilRigPosition = z.object({
  enabled: z.optional(z.boolean()),
  alignment: z.optional(MonumentAlignment),
  position: z.optional(z.number()),
});

export type OilRigPositionZodType = z.infer<typeof OilRigPosition>;

export const OilRigConfiguration = LargeMonumentConfiguration.and(
  z.object({
    biomePreference: z.optional(z.union([BiomePreference, z.null()])),
    position: z.optional(z.union([OilRigPosition, z.null()])),
  }),
);

export type OilRigConfigurationZodType = z.infer<typeof OilRigConfiguration>;

export const CustomPrefab = z.object({
  enabled: z.optional(z.boolean()),
  id: z.optional(z.union([z.string(), z.null()])),
});

export type CustomPrefabZodType = z.infer<typeof CustomPrefab>;

export const PrefabCustomizableMonumentConfiguration = LargeMonumentConfiguration.and(
  z.object({
    customPrefab: z.optional(z.union([CustomPrefab, z.null()])),
  }),
);

export type PrefabCustomizableMonumentConfigurationZodType = z.infer<typeof PrefabCustomizableMonumentConfiguration>;

export const WebhookSettingsDto = z.object({
  enabled: z.optional(z.boolean()),
  url: z.optional(z.union([z.string(), z.null()])),
});

export type WebhookSettingsDtoZodType = z.infer<typeof WebhookSettingsDto>;

export const LabConfiguration = z.object({
  minAmount: z.optional(z.int()),
  maxAmount: z.optional(z.int()),
  blocked: z.optional(z.boolean()),
  generate: z.optional(z.union([SelectionStatus, z.null()])),
});

export type LabConfigurationZodType = z.infer<typeof LabConfiguration>;

export const CustomMapSettings = z.object({
  generateRingRoad: z.optional(z.union([SelectionStatus, z.null()])),
  generateAboveGroundTrainTracks: z.optional(z.union([SelectionStatus, z.null()])),
  removeSmallPowerLines: z.optional(z.union([z.boolean(), z.null()])),
  removeLargePowerLines: z.optional(z.union([z.boolean(), z.null()])),
  removeCarWrecks: z.optional(z.union([z.boolean(), z.null()])),
  removeRivers: z.optional(z.union([z.boolean(), z.null()])),
  allowBuildingOnRoads: z.optional(z.union([z.boolean(), z.null()])),
  modifyTiers: z.optional(z.union([z.boolean(), z.null()])),
  trySpawningOutpostInCenter: z.optional(z.union([z.boolean(), z.null()])),
  terrainConfiguration: z.optional(z.union([TerrainConfiguration, z.null()])),
  oilRigConfigurations: z.optional(z.union([z.array(OilRigConfiguration), z.null()])),
  safezones: z.optional(z.union([z.array(PrefabCustomizableMonumentConfiguration), z.null()])),
  largeMonuments: z.optional(z.union([z.array(LargeMonumentConfiguration), z.null()])),
  smallMonuments: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  harbors: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  waterWells: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  caves: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  mountains: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  quarries: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  icebergs: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  iceLakes: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  ruins: z.optional(z.union([z.array(BasicMonumentConfiguration), z.null()])),
  fileName: z.optional(z.union([z.record(z.string(), z.string()), z.null()])),
  webhook: z.optional(z.union([WebhookSettingsDto, z.null()])),
  underwaterLabsConfiguration: z.optional(z.union([LabConfiguration, z.null()])),
  lakesConfiguration: z.optional(z.union([LabConfiguration, z.null()])),
  oasesConfiguration: z.optional(z.union([LabConfiguration, z.null()])),
  canyonsConfiguration: z.optional(z.union([LabConfiguration, z.null()])),
  blockedPrefabs: z.optional(z.union([z.array(z.string()), z.null()])),
  removeUndergroundTunnels: z.optional(z.union([z.boolean(), z.null()])),
  embedCargoShipPath: z.optional(z.union([z.boolean(), z.null()])),
});

export type CustomMapSettingsZodType = z.infer<typeof CustomMapSettings>;

export const ServiceResponseOfCustomMapSettings = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([CustomMapSettings, z.null()])),
});

export type ServiceResponseOfCustomMapSettingsZodType = z.infer<typeof ServiceResponseOfCustomMapSettings>;

export const MapGetByUrlRequest = z.record(z.string(), z.never());

export type MapGetByUrlRequestZodType = z.infer<typeof MapGetByUrlRequest>;

export const UploadedMapDto = z.object({
  id: z.optional(z.union([z.string(), z.null()])),
  thumbnailUrl: z.optional(z.union([z.string(), z.null()])),
  uploadedUtc: z.optional(z.iso.datetime()),
  state: z.optional(MapStates),
  displayName: z.optional(z.union([z.string(), z.null()])),
  slug: z.optional(z.union([z.string(), z.null()])),
  purchaseUrl: z.optional(z.union([z.string(), z.null()])),
  seed: z.optional(z.union([z.int(), z.null()])),
  downloadUrl: z.optional(z.union([z.string(), z.null()])),
  note: z.optional(z.union([z.string(), z.null()])),
  estimatedDeletionDate: z.optional(z.union([z.iso.datetime(), z.null()])),
});

export type UploadedMapDtoZodType = z.infer<typeof UploadedMapDto>;

export const ServiceResponseOfUploadedMapDto = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([UploadedMapDto, z.null()])),
});

export type ServiceResponseOfUploadedMapDtoZodType = z.infer<typeof ServiceResponseOfUploadedMapDto>;

export const MapUploadNormalDto = z.object({
  map: z.string(),
  note: z.optional(
    z.union([
      z
        .string()
        .min(0)
        .max(100)
        .regex(/^[A-Za-z0-9 _.()-]*$/),
      z.null(),
    ]),
  ),
  staging: z.optional(z.boolean()),
});

export type MapUploadNormalDtoZodType = z.infer<typeof MapUploadNormalDto>;

export const CreateApiCustomMapRequestDto = z.object({
  orgId: z.optional(z.union([z.string(), z.null()])),
  mapParameters: z.optional(MapGenerationRequestDto),
  customMapSettings: z.optional(CustomMapSettings),
});

export type CreateApiCustomMapRequestDtoZodType = z.infer<typeof CreateApiCustomMapRequestDto>;

export const CreateApiCustomMapRequestFromConfigDto = z.object({
  mapParameters: z.optional(MapGenerationRequestDto),
  configName: z.optional(z.string()),
});

export type CreateApiCustomMapRequestFromConfigDtoZodType = z.infer<typeof CreateApiCustomMapRequestFromConfigDto>;

export const CustomMapSettingsDto = z.object({
  id: z.optional(z.union([z.string(), z.null()])),
  name: z.optional(z.union([z.string(), z.null()])),
  settings: z.optional(z.union([CustomMapSettings, z.null()])),
});

export type CustomMapSettingsDtoZodType = z.infer<typeof CustomMapSettingsDto>;

export const ServiceResponseOfListOfCustomMapSettingsDto = z.object({
  meta: z.optional(z.union([MetaDto, z.null()])),
  data: z.optional(z.union([z.array(CustomMapSettingsDto), z.null()])),
});

export type ServiceResponseOfListOfCustomMapSettingsDtoZodType = z.infer<
  typeof ServiceResponseOfListOfCustomMapSettingsDto
>;

export const ZRustMapsApiFeaturesPublicApiSearchSearchByFilterData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    filterId: z.union([z.string(), z.null()]),
  }),
  query: z.object({
    page: z.int(),
    staging: z.optional(z.union([z.boolean(), z.null()])),
    orgId: z.optional(z.union([z.string(), z.null()])),
    customMaps: z.optional(z.union([z.boolean(), z.null()])),
    sortBy: z.optional(z.union([z.string(), z.null()])),
  }),
});

export type RustMapsApiFeaturesPublicApiSearchSearchByFilterDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiSearchSearchByFilterData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiSearchSearchByFilterResponse =
  PagedServiceResponseOfIEnumerableOfMapThumbnailApidto;

export type RustMapsApiFeaturesPublicApiSearchSearchByFilterResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiSearchSearchByFilterResponse
>;

export const ZRustMapsApiFeaturesPublicApiSearchSearchRawData = z.object({
  body: MapSearchRequest,
  path: z.optional(z.never()),
  query: z.object({
    page: z.int(),
    staging: z.optional(z.union([z.boolean(), z.null()])),
    includeAllProtocols: z.optional(z.union([z.boolean(), z.null()])),
    orgId: z.optional(z.union([z.string(), z.null()])),
    customMaps: z.optional(z.union([z.boolean(), z.null()])),
    ignoreVisitedMaps: z.optional(z.union([z.boolean(), z.null()])),
    sortBy: z.optional(z.union([z.string(), z.null()])),
  }),
});

export type RustMapsApiFeaturesPublicApiSearchSearchRawDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiSearchSearchRawData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiSearchSearchRawResponse =
  PagedServiceResponseOfIEnumerableOfMapThumbnailApidto;

export type RustMapsApiFeaturesPublicApiSearchSearchRawResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiSearchSearchRawResponse
>;

export const ZRustMapsApiFeaturesPublicApiMiscGetLimitsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      "x-org-id": z.optional(z.union([z.string(), z.null()])),
    }),
  ),
});

export type RustMapsApiFeaturesPublicApiMiscGetLimitsDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMiscGetLimitsData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiMiscGetLimitsResponse = ServiceResponseOfMapGenerationStatsOverviewDto;

export type RustMapsApiFeaturesPublicApiMiscGetLimitsResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMiscGetLimitsResponse
>;

export const ZRustMapsApiFeaturesPublicApiMapsCreateData = z.object({
  body: MapGenerationRequestDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export type RustMapsApiFeaturesPublicApiMapsCreateDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsCreateData
>;

export const ZRustMapsApiFeaturesPublicApiMapsCreateResponse = z.union([z.unknown(), ServiceResponseOfMapStatusDto]);

export type RustMapsApiFeaturesPublicApiMapsCreateResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsCreateResponse
>;

export const ZRustMapsApiFeaturesPublicApiMapsGetIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    mapId: z.union([z.string(), z.null()]),
  }),
  query: z.optional(z.never()),
});

export type RustMapsApiFeaturesPublicApiMapsGetIdDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetIdData
>;

/**
 * Returns map data
 */
export const ZRustMapsApiFeaturesPublicApiMapsGetIdResponse = ServiceResponseOfMapApidto;

export type RustMapsApiFeaturesPublicApiMapsGetIdResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetIdResponse
>;

export const ZRustMapsApiFeaturesPublicApiMapsGetSeedSizeData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    size: z.union([z.string(), z.null()]),
    seed: z.union([z.string(), z.null()]),
  }),
  query: z.object({
    staging: z.boolean(),
  }),
});

export type RustMapsApiFeaturesPublicApiMapsGetSeedSizeDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetSeedSizeData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiMapsGetSeedSizeResponse = ServiceResponseOfMapApidto;

export type RustMapsApiFeaturesPublicApiMapsGetSeedSizeResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetSeedSizeResponse
>;

export const ZRustMapsApiFeaturesPublicApiMapsGetSettingsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    mapId: z.union([z.string(), z.null()]),
  }),
  query: z.optional(z.never()),
});

export type RustMapsApiFeaturesPublicApiMapsGetSettingsByIdDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetSettingsByIdData
>;

/**
 * Returns custom map settings
 */
export const ZRustMapsApiFeaturesPublicApiMapsGetSettingsByIdResponse = ServiceResponseOfCustomMapSettings;

export type RustMapsApiFeaturesPublicApiMapsGetSettingsByIdResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetSettingsByIdResponse
>;

export const ZRustMapsApiFeaturesPublicApiMapsGetUrlData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    url: z.union([z.string(), z.null()]),
  }),
});

export type RustMapsApiFeaturesPublicApiMapsGetUrlDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetUrlData
>;

/**
 * Returns map data
 */
export const ZRustMapsApiFeaturesPublicApiMapsGetUrlResponse = ServiceResponseOfMapApidto;

export type RustMapsApiFeaturesPublicApiMapsGetUrlResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsGetUrlResponse
>;

export const ZRustMapsApiFeaturesPublicApiMapsUploadData = z.object({
  body: MapUploadNormalDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export type RustMapsApiFeaturesPublicApiMapsUploadDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsUploadData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiMapsUploadResponse = ServiceResponseOfUploadedMapDto;

export type RustMapsApiFeaturesPublicApiMapsUploadResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiMapsUploadResponse
>;

export const ZRustMapsApiFeaturesPublicApiCustomMapsDefaultConfigData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export type RustMapsApiFeaturesPublicApiCustomMapsDefaultConfigDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsDefaultConfigData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiCustomMapsDefaultConfigResponse = ServiceResponseOfCustomMapSettings;

export type RustMapsApiFeaturesPublicApiCustomMapsDefaultConfigResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsDefaultConfigResponse
>;

export const ZRustMapsApiFeaturesPublicApiCustomMapsCreateData = z.object({
  body: CreateApiCustomMapRequestDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      "x-org-id": z.optional(z.union([z.string(), z.null()])),
    }),
  ),
});

export type RustMapsApiFeaturesPublicApiCustomMapsCreateDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsCreateData
>;

export const ZRustMapsApiFeaturesPublicApiCustomMapsCreateResponse = z.union([
  z.unknown(),
  ServiceResponseOfMapStatusDto,
]);

export type RustMapsApiFeaturesPublicApiCustomMapsCreateResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsCreateResponse
>;

export const ZRustMapsApiFeaturesPublicApiCustomMapsCreateFromConfigData = z.object({
  body: CreateApiCustomMapRequestFromConfigDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      "x-org-id": z.optional(z.union([z.string(), z.null()])),
    }),
  ),
});

export type RustMapsApiFeaturesPublicApiCustomMapsCreateFromConfigDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsCreateFromConfigData
>;

export const ZRustMapsApiFeaturesPublicApiCustomMapsCreateFromConfigResponse = z.union([
  z.unknown(),
  ServiceResponseOfMapStatusDto,
]);

export type RustMapsApiFeaturesPublicApiCustomMapsCreateFromConfigResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsCreateFromConfigResponse
>;

export const ZRustMapsApiFeaturesPublicApiCustomMapsGetConfigsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export type RustMapsApiFeaturesPublicApiCustomMapsGetConfigsDataZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsGetConfigsData
>;

/**
 * Success
 */
export const ZRustMapsApiFeaturesPublicApiCustomMapsGetConfigsResponse = ServiceResponseOfListOfCustomMapSettingsDto;

export type RustMapsApiFeaturesPublicApiCustomMapsGetConfigsResponseZodType = z.infer<
  typeof ZRustMapsApiFeaturesPublicApiCustomMapsGetConfigsResponse
>;
